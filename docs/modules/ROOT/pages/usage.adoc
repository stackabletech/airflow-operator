= Usage

== Monitoring

The managed Airflow instances are automatically configured to export Prometheus metrics. See
xref:home:operators:monitoring.adoc[] for more details.

== Log aggregation

The logs can be forwarded to a Vector log aggregator by providing a discovery
ConfigMap for the aggregator and by enabling the log agent:

[source,yaml]
----
spec:
  vectorAggregatorConfigMapName: vector-aggregator-discovery
  webservers:
    config:
      logging:
        enableVectorAgent: true
        containers:
          airflow:
            loggers:
              "flask_appbuilder":
                level: WARN
  workers:
    config:
      logging:
        enableVectorAgent: true
        containers:
          airflow:
            loggers:
              "airflow.processor":
                level: INFO
  schedulers:
    config:
      logging:
        enableVectorAgent: true
        containers:
          airflow:
            loggers:
              "airflow.processor_manager":
                level: INFO
  databaseInitialization:
    logging:
      enableVectorAgent: true
----

Further information on how to configure logging, can be found in
xref:home:concepts:logging.adoc[].

== Configuration & Environment Overrides

The cluster definition also supports overriding configuration properties and environment variables, either per role or per role group, where the more specific override (role group) has precedence over the less specific one (role).

IMPORTANT: Overriding certain properties which are set by operator (such as the HTTP port) can interfere with the operator and can lead to problems. Additionally, for Airflow it is recommended
that each component has the same configuration: not all components use each setting, but some things - such as external end-points - need to be consistent for things to work as expected.

=== Configuration Properties

Airflow exposes an environment variable for every Airflow configuration setting, a list of which can be found in the https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html[Configuration Reference].

Although Kubernetes can override these settings in one of two ways (Configuration overrides, or Environment Variable overrides), the affect is the same
and currently only the latter is implemented. This is described in the following section.

=== Environment Variables

These can be set - or overwritten - at either the role level:

[source,yaml]
----
webservers:
  envOverrides:
    AIRFLOW__WEBSERVER__AUTO_REFRESH_INTERVAL: "8"
  roleGroups:
    default:
      replicas: 1
----

Or per role group:

[source,yaml]
----
webservers:
  roleGroups:
    default:
      envOverrides:
        AIRFLOW__WEBSERVER__AUTO_REFRESH_INTERVAL: "8"
      replicas: 1
----

In both examples above we are replacing the default value of the UI DAG refresh (3s) with 8s. Note that all override property values must be strings.

=== Storage for data volumes

The Airflow Operator currently does not support using https://kubernetes.io/docs/concepts/storage/persistent-volumes[PersistentVolumeClaims] for internal storage.

=== Resource Requests

include::home:concepts:stackable_resource_requests.adoc[]

If no resource requests are configured explicitely, the operator uses the following defaults:

[source,yaml]
----
workers:
  roleGroups:
    default:
      config:
        resources:
          cpu:
            min: '200m'
            max: "4"
          memory:
            limit: '2Gi'
----

== Initializing the Airflow database

Airflow comes with a default embedded database (intended only for standalone mode): for cluster usage an external database is used such as PostgreSQL, described above. This database must be initialized with an airflow schema and the Admin user defined in the airflow credentials `Secret`. This is done the first time the cluster is created and can take a few moments.

== Using Airflow

When the Airflow cluster is created and the database is initialized, Airflow can be opened in the
browser.

The Airflow port which defaults to `8080` can be forwarded to the local host:

[source,bash]
----
kubectl port-forward airflow-webserver-default-0 8080
----

Then it can be opened in the browser with `http://localhost:8080`.

Enter the admin credentials from the Kubernetes secret:

image::airflow_login.png[Login screen of Airflow]

If the examples were loaded then some dashboards are already available:

image::airflow_dags.png[Airflow UI showing example DAGs]

Click on an example DAG and then invoke the job: if the scheduler is correctly set up then the job
will run and the job tree will update automatically:

image::airflow_running.png[Airflow UI showing a running DAG]

== Authentication
Every user has to authenticate themselves before using Airflow and there are several ways of doing this.

=== Webinterface
The default setting is to view and manually set up users via the Webserver UI. Note the blue "+" button where users can be added directly:

image::airflow_security.png[Airflow Security menu]

=== LDAP

Airflow supports xref:nightly@home:concepts:authentication.adoc[authentication] of users against an LDAP server. This requires setting up an xref:nightly@home:concepts:authentication.adoc#authenticationclass[AuthenticationClass] for the LDAP server.
The AuthenticationClass is then referenced in the AirflowCluster resource as follows:

[source,yaml]
----
apiVersion: airflow.stackable.tech/v1alpha1
kind: AirflowCluster
metadata:
  name: airflow-with-ldap
spec:
  image:
    productVersion: 2.4.1
    stackableVersion: 23.4.0-rc2
  [...]
  authenticationConfig:
    authenticationClass: ldap    # <1>
    userRegistrationRole: Admin  # <2>
----

<1> The reference to an AuthenticationClass called `ldap`
<2> The default role that all users are assigned to

Users that log in with LDAP are assigned to a default https://airflow.apache.org/docs/apache-airflow/stable/security/access-control.html#access-control[Role] which is specified with the `userRegistrationRole` property.

You can follow the xref:nightly@home:tutorials:authentication_with_openldap.adoc[] tutorial to learn how to set up an AuthenticationClass for an LDAP server, as well as consulting the xref:nightly@home:reference:authenticationclass.adoc[] reference.

The users and roles can be viewed as before in the Webserver UI, but note that the blue "+" button is not available when authenticating against LDAP:

image::airflow_security_ldap.png[Airflow Security menu]

== Authorization
The Airflow Webserver delegates the https://airflow.apache.org/docs/apache-airflow/stable/security/access-control.html[handling of user access control] to https://flask-appbuilder.readthedocs.io/en/latest/security.html[Flask AppBuilder].

=== Webinterface
You can view, add to, and assign the roles displayed in the Airflow Webserver UI to existing users.

=== LDAP

Airflow supports assigning https://airflow.apache.org/docs/apache-airflow/stable/security/access-control.html#access-control[Roles] to users based on their LDAP group membership, though this is not yet supported by the Stackable operator.
All the users logging in via LDAP get assigned to the same role which you can configure via the attribute `authenticationConfig.userRegistrationRole` on the `AirflowCluster` object:

[source,yaml]
----
apiVersion: airflow.stackable.tech/v1alpha1
kind: AirflowCluster
metadata:
  name: airflow-with-ldap
spec:
  [...]
  authenticationConfig:
    authenticationClass: ldap
    userRegistrationRole: Admin  # <1>
----

<1> All users are assigned to the `Admin` role

== Monitoring

The managed Airflow instances are automatically configured to export Prometheus metrics. See
xref:home:operators:monitoring.adoc[] for more details

== Mounting DAGs

DAGs can be mounted by using a `ConfigMap` or a `PersistentVolumeClaim`. This is best illustrated with an example of each, shown in the next section.

=== via `ConfigMap`

[source,python]
----
include::example$example-configmap.yaml[]
----
----
include::example$example-airflow-dags-configmap.yaml[]
----
<1> The name of the configuration map
<2> The name of the DAG (this is a renamed copy of the `example_bash_operator.py` from the Airflow examples)
[source,yaml]
<3> The volume backed by the configuration map
<4> The name of the configuration map referenced by the Airflow cluster
<5> The name of the mounted volume
<6> The path of the mounted resource. Note that should map to a single DAG.
<7> The resource has to be defined using `subPath`: this is to prevent the versioning of configuration map elements which may cause a conflict with how Airflow propagates DAGs between its components.
<8> If the mount path described above is anything other than the standard location (the default is `$AIRFLOW_HOME/dags`), then the location should be defined using the relevant environment variable.

The advantage of this approach is that a DAG can be provided "in-line", as it were. This becomes cumbersome when multiple DAGs are to be made available in this way, as each one has to be mapped individually. For multiple DAGs it is probably easier to expose them all via a mounted volume, which is shown below.

=== via PersistentVolumeclaim

[source,yaml]
----
include::example$example-pvc.yaml[]
----
[source,yaml]
----
include::example$example-airflow-dags-pvc.yaml[]
----
<1> The name of the `PersistentVolumeClaim` that references the PV
<2> Job used to populate the `PersistentVolumeClaim` with DAG files
<3> The volume name that will be mounted as a target for the DAG files
<4> Defines the `Volume` backed by the PVC, local to the Custom Resource
<5> The `VolumeMount` used by the Custom Resource
<6> The path for the `VolumeMount`
<7> The command used to access/download the DAG files to a specified location
<8> The `Volume` used by this Custom Resource
<9> The `PersistentVolumeClaim` that backs this `Volume`
<10> The `VolumeMount` referencing the `Volume` in the previous step
<11> The path where this `Volume` is located for each role (webserver, worker, scheduler)
<12> If the mount path described above is anything other than the standard location (the default is `$AIRFLOW_HOME/dags`), then the location should be defined using the relevant environment variable.

== Node selection

Airflow expects that all its components (webserver, scheduler, workers etc.) have access to the DAG folder. If this is mounted via a PersistentVolumeClaim, then the permissible https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes[access modes] on that claim may require that a specific node is selected. This can be done by providing a label-match as shown below:

[source,yaml]
----
  workers:
    roleGroups:
      default:
        envOverrides:
          AIRFLOW__CORE__DAGS_FOLDER: "/stackable/external-dags"
        replicas: 1
        selector:
          matchLabels:
            node: "2"
----

== Applying Custom Resources

Airflow can be used to apply custom resources from within a cluster. An example of this could be a SparkApplication job that is to be triggered by Airflow. The steps below describe how this can be done.

=== Define an in-cluster Kubernetes connection

An in-cluster connection can either be created from within the Webserver UI (note that the "in cluster configuration" box is ticked):

image::airflow_connection_ui.png[Airflow Connections]

Alternatively, the connection can be https://airflow.apache.org/docs/apache-airflow/stable/howto/connection.html[defined] by an environment variable in URI format:

[source]
AIRFLOW_CONN_KUBERNETES_IN_CLUSTER: "kubernetes://?__extra__=%7B%22extra__kubernetes__in_cluster%22%3A+true%2C+%22extra__kubernetes__kube_config%22%3A+%22%22%2C+%22extra__kubernetes__kube_config_path%22%3A+%22%22%2C+%22extra__kubernetes__namespace%22%3A+%22%22%7D"

This can be supplied directly in the custom resource for all roles (Airflow expects configuration to be common across components):

[source,yaml]
----
include::example$example-airflow-incluster.yaml[]
----

=== Define a cluster role for Airflow to create SparkApplication resources

Airflow cannot create or access SparkApplication resources by default - a cluster role is required for this:

[source,yaml]
----
include::example$example-airflow-spark-clusterrole.yaml[]
----

and a corresponding cluster role binding:

[source,yaml]
----
include::example$example-airflow-spark-clusterrolebinding.yaml[]
----

=== DAG code

Now for the DAG itself. The job to be started is a simple Spark job that calculates the value of pi:

[source,yaml]
----
include::example$example-pyspark-pi.yaml[]
----

This will called from within a DAG by using the connection that was defined earlier. It will be wrapped by the `KubernetesHook` that the Airflow Kubernetes provider makes available. There are two classes that are used to:

- start the job
- monitor the status of the job

These are written in-line in the python code below, though this is just to make it clear how the code is used (the classes `SparkKubernetesOperator` and `SparkKubernetesSensor` will be used for all custom resources and thus are best defined as separate python files that the DAG would reference).

[source,python]
----
include::example$example-spark-dag.py[]
----
<1> the wrapper class used for calling the job via `KubernetesHook`
<2> the connection that created for in-cluster usage
<3> the wrapper class used for monitoring the job via `KubernetesHook`
<4> the start of the DAG code
<5> the initial task to invoke the job
<6> the subsequent task to monitor the job
<7> the jobs are chained together in the correct order

Once this DAG is xref:usage.adoc#_mounting_dags[mounted] in the DAG folder it can be called and its progress viewed from within the Webserver UI:

image::airflow_dag_graph.png[Airflow Connections]

Clicking on the "spark_pi_monitor" task and selecting the logs shows that the status of the job has been tracked by Airflow:

image::airflow_dag_log.png[Airflow Connections]
