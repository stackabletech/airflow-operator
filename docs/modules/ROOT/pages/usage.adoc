= Usage

Airflow can run in standalone mode (see https://airflow.apache.org/docs/apache-airflow/stable/start/local.html) but requires 2 external dependencies if we want to run jobs across more than one worker: these
dependencies are

- an external database (e.g. postgresql) for user/job data, and
- a queuing component such as Redis.

== External dependencies for the Airflow users/job data and job queues

For testing purposes, first add the bitnami repository to helm:

[source,bash]
----
helm repo add bitnami https://charts.bitnami.com/bitnami
----

You can spin up a PostgreSQL database with the following command:

[source,bash]
----
helm install airflow-postgresql bitnami/postgresql --version 11.0.0 \
    --set auth.username=airflow \
    --set auth.password=airflow \
    --set auth.database=airflow
----

A Redis instance can be setup in a similar way:

[source,bash]
----
helm install redis bitnami/redis \
    --set auth.password=redis
----

== Secret with Airflow credentials

A secret with the necessary credentials must be created:

[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: simple-airflow-credentials
type: Opaque
stringData:
  adminUser.username: airflow
  adminUser.firstname: Airflow
  adminUser.lastname: Admin
  adminUser.email: airflow@airflow.com
  adminUser.password: airflow
  connections.secretKey: thisISaSECRET_1234
  connections.sqlalchemyDatabaseUri: postgresql+psycopg2://airflow:airflow@airflow-postgresql.default.svc.cluster.local/airflow
  connections.celeryResultBackend: db+postgresql://airflow:airflow@airflow-postgresql.default.svc.cluster.local/airflow
  connections.celeryBrokerUrl: redis://:redis@redis-master:6379/0
----

The `connections.secretKey` will be used for securely signing the session cookies and can be used
for any other security related needs by extensions. It should be a long random string of bytes.

`connections.sqlalchemyDatabaseUri` must contain the connection string to the SQL database storing
the Airflow metadata.

`connections.celeryResultBackend` must contain the connection string to the SQL database storing
the job metadata (in the example above we are using the same postgresql database for both).

`connections.celeryBrokerUrl` must contain the connection string to the Redis instance used for queuing
the jobs submitted to the airflow worker(s).

The `adminUser` fields are used by the `init` command to create an admin user.

== Creation of an Airflow Cluster

An Airflow cluster must be created as a custom resource:

[source,yaml]
----
apiVersion: airflow.stackable.tech/v1alpha1
kind: AirflowCluster
metadata:
  name: airflow
spec:
  version: 2.2.4-python3.9
  statsdExporterVersion: v0.22.4
  executor: CeleryExecutor
  loadExamples: true
  exposeConfig: false
  webservers:
    roleGroups:
      default:
        config:
          credentialsSecret: simple-airflow-credentials
  workers:
    roleGroups:
      default:
        config:
          credentialsSecret: simple-airflow-credentials
        replicas: 2
  schedulers:
    roleGroups:
      default:
        config:
          credentialsSecret: simple-airflow-credentials
----

Where:

- `metadata.name` contains the name of the Airflow cluster
- the label of the Docker image provided by Stackable must be set in `spec.version`
- `spec.statsdExporterVersion` must contain the tag of a statsd-exporter Docker image in the Stackable repository.
- `spec.executor`: this setting determines how the cluster will run (for more information see https://airflow.apache.org/docs/apache-airflow/stable/executor/index.html#executor-types): the `CeleryExecutor`
is the recommended setting although `SequentialExecutor` (all jobs run in one process in series) and `LocalExecutor`
(whereby all jobs are run on one node, using whatever parallelism is possible) are also supported
- importing the sample workflows is determined by `loadExamples`
- `exposeConfig` allows the contents of the configuration file `airflow.cfg` to be exposed via the webserver UI. This is only for debugging purposes and should be set to `false` otherwise as it presents a security risk.
- the previously created secret must be referenced in `credentialsSecret`

Each cluster requires 3 components:

- `webservers`: this provides the main UI for user-interaction
- `workers`: the nodes over which the job workload will be distributed by the scheduler
- `schedulers`: responsible for triggering jobs and persisting their metadata to the backend database

== Monitoring

The managed Airflow instances are automatically configured to export Prometheus metrics. See
xref:home::monitoring.adoc[] for more details.

== Configuration & Environment Overrides

The cluster definition also supports overriding configuration properties and environment variables, either per role or per role group, where the more specific override (role group) has precedence over the less specific one (role).

IMPORTANT: Overriding certain properties which are set by operator (such as the HTTP port) can interfere with the operator and can lead to problems. Additionally for Airflow it is recommended
that each component has the same configuration: not all components use each setting, but some things - such as external end-points - need to be consistent for things to work as expected.

=== Configuration Properties

Airflow exposes an environment variable for every configuration setting, a list of which can be found in the https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html[Configuration Reference].

Although Kubernetes can override these settings in one of two ways (Configuration overrides, or Environment Variable overrides), the affect is the same
and currently only the latter is implemented. This is described in the following section.

=== Environment Variables

These can be set - or overwritten - at either the role level:

[source,yaml]
----
  webservers:
    envOverrides:
      AIRFLOW__WEBSERVER__AUTO_REFRESH_INTERVAL: "8"
    roleGroups:
      default:
        config:
          credentialsSecret: simple-airflow-credentials
----

Or per role group:

[source,yaml]
----
  webservers:
    roleGroups:
      default:
        envOverrides:
          AIRFLOW__WEBSERVER__AUTO_REFRESH_INTERVAL: "8"
        config:
          credentialsSecret: simple-airflow-credentials
----

In both examples above we are replacing the default value of the UI DAG refresh (3s) with 8s. Note that all override property values must be strings.

== Initializing the Airflow database

If the database is not initialized yet for Airflow, the `init` command must be executed: the
command initializes the database by creating the necessary database tables, creating the admin user
account, and loading examples if desired. The webserver will not be available/ready until this initialization
step has been completed.

[source,yaml]
----
apiVersion: command.airflow.stackable.tech/v1alpha1
kind: Init
metadata:
  name: airflow-cluster-command-init
spec:
  clusterRef:
    name: airflow
  credentialsSecret: simple-airflow-credentials
----

`spec.clusterRef.name` refers to the name of the Airflow cluster.

The previously created secret must be referenced in `spec.credentialsSecret`.

A Kubernetes job is created which starts a pod to initialize the database. This can take a while.

== Using Airflow

When the Airflow cluster is created and the database is initialized, Airflow can be opened in the
browser.

The Airflow port which defaults to `8080` can be forwarded to the local host:

[source,bash]
----
kubectl port-forward airflow-webserver-default-0 8080
----

Then it can be opened in the browser with `http://localhost:8080`.

Enter the admin credentials from the Kubernetes secret:

image::airflow_login.png[Login screen of Airflow]

If the examples were loaded then some dashboards are already available:

image::airflow_dags.png[Airflow UI showing example DAGs]

Click on an example DAG and then invoke the job: if the scheduler is correctly set up then the job
will run and the job tree will update automatically:

image::airflow_running.png[Airflow UI showing a running DAG]

== Monitoring

The managed Airflow instances are automatically configured to export Prometheus metrics. See
xref:home::monitoring.adoc[] for more details

== Mounting DAGs

DAGs can be mounted by using a `ConfigMap` or a `PersistentVolumeClaim`. This is best illustrated with an example of each, shown in the next section.

=== via `ConfigMap`

[source,python]
----
include::example$example-configmap.yaml[]
----
----
include::example$example-airflow-dags-configmap.yaml[]
----
<1> The name of the configuration map
<2> The name of the DAG (this is a renamed copy of the `example_bash_operator.py` from the Airflow examples)
[source,yaml]
<3> The volume backed by the configuration map
<4> The name of the configuration map referenced by the Airflow cluster
<5> The name of the mounted volume
<6> The path of the mounted resource. Note that should map to a single DAG.
<7> The resource has to be defined using `subPath`: this is to prevent the versioning of configuration map elements which may cause a conflict with how Airflow propagates DAGs between its components.
<8> If the mount path described above is anything other than the standard location (the default is `$AIRFLOW_HOME/dags`), then the location should be defined using the relevant environment variable.

The advantage of this approach is that a DAG can be provided "in-line", as it were. This becomes cumbersome when multiple DAGs are to be made available in this way, as each one has to be mapped individually. For multiple DAGs it is probably easier to expose them all via a mounted volume, which is shown below.

=== via `PersistentVolumeclaim`

[source,yaml]
----
include::example$example-pvc.yaml[]
----
[source,yaml]
----
include::example$example-airflow-dags-pvc.yaml[]
----
<1> The name of the `PersistentVolumeClaim` that references the PV
<2> Job used to populate the `PersistentVolumeClaim` with DAG files
<3> The volume name that will be mounted as a target for the DAG files
<4> Defines the `Volume` backed by the PVC, local to the Custom Resource
<5> The `VolumeMount` used by the Custom Resource
<6> The path for the `VolumeMount`
<7> The command used to access/download the DAG files to a specified location
<8> The `Volume` used by this Custom Resource
<9> The `PersistentVolumeClaim` that backs this `Volume`
<10> The `VolumeMount` referencing the `Volume` in the previous step
<11> The path where this `Volume` is located for each role (webserver, worker, scheduler)
<12> If the mount path described above is anything other than the standard location (the default is `$AIRFLOW_HOME/dags`), then the location should be defined using the relevant environment variable.